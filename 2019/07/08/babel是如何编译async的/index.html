<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Cary Yang,carynihility@gmail.com"><meta property="og:type" content="article"><meta property="og:image" content="/images/favicon.ico"><title>babel是如何编译async的 · 黑胖子的博客</title><meta property="og:description" content="前言ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。
至今为止有八个ECMA-262版本发表



版本"><meta name="keywords" content="Angular, Babel, CLI, CSS-in-JS, Gatsby, GraphQL, JavaScript, React, TypeScript, WebAssembly, github, npm, vue, webpack, 服务端渲染, JavaScript, 前端工具资源"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta content="codeva-omByo1T2Oa" name="baidu-site-verification"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- Global site tag (gtag.js) - Google Analytics --><script src="https://www.googletagmanager.com/gtag/js?id=G-8T3DP764SR"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-8T3DP764SR');</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">黑胖子的博客</a></h3><div class="description"><p>The sun is the nihility in your delusion eyes.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/yangyichen"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="http://instagram.com/nihility__"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><div class="footer"><a target="_blank" href="javascript:;"><span>Theme by</span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai</a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><!--li--><!--  if is_current('weekly')--><!--    a.current(href="/tags/weekly")= __('Weekly')--><!--  else--><!--    a(href="/tags/weekly")= __('Weekly')--></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img src="/images/avatar.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h2><a>babel是如何编译async的</a></h2></div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<p>至今为止有八个ECMA-262版本发表</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>发表日期</th>
<th>与前版本的差异</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>1    | 1997年6月    |首版<br>2    | 1998年6月    |格式修正，以使得其形式与ISO/IEC16262国际标准一致<br>3    | 1999年12月    |强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变<br>4    | 放弃    |由于关于语言的复杂性出现分歧，第4版本被放弃，其中的部分成为了第5版本及Harmony的基础<br>5    | 2009年12月    |新增“严格模式（strict mode）”，一个子集用作提供更彻底的错误检查,以避免结构出错。澄清了许多第3版本的模糊规范，并适应了与规范不一致的真实世界实现的行为。增加了部分新功能，如getters及setters，支持JSON以及在对象属性上更完整的反射<br>5.1    | 2011年6月    |ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。<br>6    | 2015年6月    |ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。<br>7    | 2016年6月    |ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性<br>8    | 2017年6月    |ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性<br>9    | 2018年6月    |ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。</p>
<p>前端技术不断的在发展,但是为了适应其发展,不得不做出一些牺牲,如抛弃老旧的浏览器.那么问题来了,我们是做服务的,不可能要求每个用户的浏览器都升级到最新的,所以不得不做一些兼容方案.于是babel为我们推出了一系列解决方案.</p>
<h1 id="babel是如何运行的"><a href="#babel是如何运行的" class="headerlink" title="babel是如何运行的"></a>babel是如何运行的</h1><p>首先我们来看一下babel内部依赖了哪些库:</p>
<h2 id="核心包"><a href="#核心包" class="headerlink" title="核心包"></a>核心包</h2><ul>
<li>babel-core：babel转译器本身，提供了babel的转译API，如babel.transform等，用于对代码进行转译。像webpack的babel-loader就是调用这些API来完成转译过程的。</li>
<li>babylon：js的词法解析器</li>
<li>babel-traverse：用于对AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给plugin用</li>
<li>babel-generator：根据AST生成代码</li>
</ul>
<h2 id="功能包"><a href="#功能包" class="headerlink" title="功能包"></a>功能包</h2><ul>
<li>babel-types：用于检验、构建和改变AST树的节点</li>
<li>babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点</li>
<li>babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用</li>
<li>babel-code-frames：用于生成错误信息，打印出错误点源代码帧以及指出出错位置</li>
<li>babel-plugin-xxx：babel转译过程中使用到的插件，其中babel-plugin-transform-xxx是transform步骤使用的</li>
<li>babel-preset-xxx：transform阶段使用到的一系列的plugin</li>
<li>babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装</li>
<li>babel-runtime：功能类似babel-polyfill，一般用于library或plugin中，因为它不会污染全局作用域</li>
</ul>
<h2 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h2><ul>
<li>babel-cli：babel的命令行工具，通过命令行对js代码进行转译</li>
<li>babel-register：通过绑定node.js的require来自动转译require引用的js代码文件</li>
</ul>
<p>其实babel的作用和浏览器解析js,解析css的模式相同,都是用解析器来拆分各个单词,数字,符号等,然后应用语法规则.接下来词法分析器则把一些无关的空格字符去除,构建成抽象语法树.最后则用babel-generator生成代码.</p>
<p>至于其他一些包感兴趣的可以自己了解一下.</p>
<p>那么回到这次的主题:为什么我们项目中不能解析async呢?</p>
<p>其实原因很简单,就是因为babel-core的版本选择的有问题,所以对一些高版本的语法并不支持.</p>
<p>那么我们先来看一下如果在官方的<a target="_blank" rel="noopener" href="https://babeljs.io/repl">转换工具中</a>,一个纯正的async await方法会变成什么样子的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">sleep</span> = m =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, m))</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;await&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转换后(部分代码已经精简)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (info.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_asyncToGenerator</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> gen = fn.<span class="title function_">apply</span>(self, args);</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">_next</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title function_">asyncGeneratorStep</span>(gen, resolve, reject, _next, _throw, <span class="string">&quot;next&quot;</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">_next</span>(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _test.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  _test = <span class="title function_">_asyncToGenerator</span>(</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    regeneratorRuntime.<span class="title function_">mark</span>(<span class="keyword">function</span> <span class="title function_">_callee</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> sleep;</span><br><span class="line">      <span class="keyword">return</span> regeneratorRuntime.<span class="title function_">wrap</span>(<span class="keyword">function</span> <span class="title function_">_callee$</span>(<span class="params">_context</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">switch</span> ((_context.<span class="property">prev</span> = _context.<span class="property">next</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              sleep = <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">m</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">r</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="built_in">setTimeout</span>(r, m);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;;</span><br><span class="line"></span><br><span class="line">              _context.<span class="property">next</span> = <span class="number">3</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;await&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">              <span class="keyword">return</span> _context.<span class="title function_">stop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, _callee);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> _test.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实这段转换后的代码也兼容了es2015,如果不勾选的话会出现Generator函数以及yield,我就一步到位全都勾上了.可以看到整个函数是被_asyncToGenerator方法封装后抛出一个switch case函数,初步可以判断是根据不同的条件进行不同的操作.</p>
<p>但是实际运行发现报错了,提示<code>regeneratorruntime is not defined</code>,看了下代码,发现这个方法babel并没有帮我生成,看来是要自己引入了.话不多说直接<code>yarn add regenerator-runtime</code>就可以了.</p>
<p>那我们再看一下<code>regenerator-runtime</code>这个包吧.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Generator</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GeneratorFunction</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GeneratorFunctionPrototype</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Gp</span> = <span class="title class_">GeneratorFunctionPrototype</span>.<span class="property"><span class="keyword">prototype</span></span> =</span><br><span class="line">  <span class="title class_">Generator</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">IteratorPrototype</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">GeneratorFunction</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Gp</span>.<span class="property">constructor</span> = <span class="title class_">GeneratorFunctionPrototype</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">GeneratorFunctionPrototype</span>.<span class="property">constructor</span> = <span class="title class_">GeneratorFunction</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">GeneratorFunctionPrototype</span>[toStringTagSymbol] =</span><br><span class="line"><span class="title class_">GeneratorFunction</span>.<span class="property">displayName</span> = <span class="string">&quot;GeneratorFunction&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码构建了一堆看起来很复杂的关系链，其实这是参照着<code>ES6规范</code>(<a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-constructor)构建的关系链">https://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-constructor)构建的关系链</a>:</p>
<p><img src="/imgs/generator.jpg" alt=""></p>
<p>这个包抛出了8个方法,我们选其中用到的方法</p>
<ul>
<li>mark</li>
<li>wrap</li>
</ul>
<p>来分析一下各自的作用.</p>
<h4 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">mark</span> = <span class="keyword">function</span>(<span class="params">genFun</span>) &#123;</span><br><span class="line">  genFun.<span class="property">__proto__</span> = <span class="title class_">GeneratorFunctionPrototype</span>;</span><br><span class="line">  genFun.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Gp</span>);</span><br><span class="line">  <span class="keyword">return</span> genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出,mark的主要作用就是保证传入的方法的作用域以及原型指向是和Gp这个变量一致的.</p>
<p>而Gp则是一个生成器函数,生成器挂载了3个方法,分别是next,return和throw.</p>
<p>next返回一个由yield表达式生成的值.<br>return返回给定的值并结束生成器.<br>throw向生成器抛出一个错误.</p>
<h4 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a>wrap</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params">innerFn, outerFn, self, tryLocsList</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> protoGenerator = outerFn &amp;&amp; outerFn.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Generator</span> ? outerFn : <span class="title class_">Generator</span>;</span><br><span class="line">  <span class="keyword">var</span> generator = <span class="title class_">Object</span>.<span class="title function_">create</span>(protoGenerator.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> <span class="title class_">Context</span>(tryLocsList || []);</span><br><span class="line">  generator.<span class="property">_invoke</span> = <span class="title function_">makeInvokeMethod</span>(innerFn, self, context);</span><br><span class="line">  <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过代码可以看出,我们传进去的_callee$就是innerFn,这个innerFn通过makeInvokeMethod方法创造了和刚刚make相同的3个方法.</p>
<p>而context相当于一个全局变量,存放着当前方法的运行环境,比如next表示下一步运行哪行代码,done表示promise是否结束,finish则表示当前函数是否全部走完.</p>
<p>根据asyncGeneratorStep方法来看,通过info.done是否为true来判断当前的方法是否结束,从而可以重新开一个promise来阻断进程.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实不管是async还是generator,其实返回的都是promise,由此可见,promise对我们日常的开发有多么重要.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-08</span><i class="fa fa-comment-o"></i><a href="/2019/07/08/babel%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91async%E7%9A%84/#comments">评论</a><i class="fa fa-tag"></i><a href="/tags/技术/" title="技术" class="tag">技术 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2019/08/08/%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAchrome%E6%8F%92%E4%BB%B6/" title="编写你的第一个chrome插件" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2019/05/30/package.json%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/" title="package.json文件解析" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'heipangzi';
var disqus_identifier = '2019/07/08/babel是如何编译async的/';
var disqus_title = 'babel是如何编译async的';
var disqus_url = 'https://cary.im/2019/07/08/babel是如何编译async的/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//heipangzi.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>